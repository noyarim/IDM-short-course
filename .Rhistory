# Plot S, I, R stratified by vaccination status
ggplot(alpha_out_all)+
geom_point(aes(x=time,y=I_NotV,color='Not vaccinated'))+
geom_point(aes(x=time,y=I_V,color='Vaccinated'))+
ylab("Infections")+
facet_wrap(.~alpha)+
scale_color_manual(values=c("green","tomato"))+
theme_bw()
# Plot prevalence of I
ggplot(alpha_out_all) +
geom_point(aes(x=time,y=I/N))+
facet_wrap(.~alpha)+
ylab("Prevalence of infection")+
theme_bw()
# Plot cumulative number of infections
ggplot(alpha_out_all) +
geom_point(aes(x=time,y=C))+
facet_wrap(.~alpha)+
ylab("Cumulative infections")+
theme_bw()
# Breakthrough infection
ggplot(alpha_out_all)+
geom_point(aes(x=time,y=I_V))+
facet_wrap(.~alpha)+
ylab("Number of breakthrough infections")+
theme_bw()
# 3. Ratio of effective contact rate among infected individuals with and without vaccination
mbeta_list <- seq(1,0.7,length.out=3) # a vector of mbeta
mbeta_out_all <- data.frame() # an empty dataset to save outputs
for(this_mbeta in mbeta_list){
temp_param <- parameters # copy parameters
temp_param[['mbeta']] <- this_mbeta # replace mbeta
this_out <- data.frame(ode(y = state.ip, times = times, func = OpenSIR_Vax_ip2, parms = temp_param)) # run ode solver
# compute S,I,R and save mbeta in this cycle
this_out <- this_out %>%
mutate(N = S_NotV + S_V + I_NotV + I_V + R_NotV + R_V,
mbeta = this_mbeta,
S = S_NotV + S_V,
I = I_NotV + I_V,
R = R_NotV + R_V)
# Stack the result
if(this_mbeta == mbeta_list[1]){
mbeta_out_all <- this_out
}else{
mbeta_out_all <- rbind(mbeta_out_all, this_out)
}
}
# change the data to long-form data
mbeta_out_all_t <- melt(mbeta_out_all%>% select(time,S,I,R,N,mbeta), id.vars=c("time","mbeta","N"))
# Plot S,I,R
ggplot(mbeta_out_all_t) +
geom_line(aes(x=time,y=value/N*100,color=variable))+
facet_wrap(.~mbeta)+
ylab("Proportion of population")+
theme_bw()
# plot cumulative number of infections
ggplot(mbeta_out_all) +
geom_point(aes(x=time,y=C))+
facet_wrap(.~mbeta)+
ylab("Cumulative infections")+
theme_bw()
# C. SIR model with quarantine
OpenSIR_Qrtn<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
N = S + I + Q + R
#SIR with quarantine
dS<- -beta*S*I/N + birth*N - death*S
dI <- beta*S*I/N - death*I - q*I - gamma*I
dQ <- q*I - death*Q - gamma*Q
dR <- gamma*I + gamma*Q - death*R
dC <- beta*S*I/N
# return the rates of change as a list
list(c(dS, dI, dQ, dR, dC))
})
}
# 2. Define parameters and starting compartment sizes
parameters <- c(beta = 0.5, #effective contact rate (aka transmission rate)
beta.1 = 0.5, # transmission rate given no-vaccination
mbeta = 0.5, # 1 if no change in infectiousness with vaccination,
# less than 1 if reduced infectiousness with vaccination
gamma = 0.3, #recovery rate (1/duration infection)
birth = 0.03, #birth rate (per capita)
death = 0.03, #all-cause mortality rate
omega = 0, # waning immunity
mu = 0.01, # vaccination rate
alpha = 0.3, # vaccine effectiveness
q = 0.02 # quarantine rate
)
# Initial state
state.q <- c(S = 99999, #population of 100,000, 1 person starts of infected
I = 1,
Q = 0,
R = 0,
C = 0)
T_end <- 500 #run model for 500 time steps (e.g. months)
times <- seq(0, T_end, by = 1) #runs the model for 500 time steps (e.g. months), and computes output at each time step
# Run ODE solver
output.qrtn <- ode(y = state.q, times = times, func = OpenSIR_Qrtn, parms = parameters)
# Plot base-case result
output.qrtn.t <- melt(as.data.frame(output.qrtn) %>% select(-C), id.vars="time")
ggplot(output.qrtn.t)+
geom_line(aes(time,value,color=variable))+
ylab("Number of individuals")+
theme_bw()
# 4. Quarantine rate
q_list <- c(0,0.02,0.05) # a vector of quarantine rate
q_out_all <- data.frame() # an empty dataset to save the outcome
for(this_q in q_list){
temp_param <- parameters #copy parameter
temp_param[['q']] <- this_q # replace q
# run ode solver
this_out <- data.frame(ode(y = state.q, times = times, func = OpenSIR_Qrtn, parms = temp_param))
# save q value in this cycle
this_out <- this_out %>%
mutate(N = S+I+R+Q,
q = this_q)
# stack the result
if(this_q == q_list[1]){
q_out_all <- this_out
}else{
q_out_all <- rbind(q_out_all, this_out)
}
}
# change the dataset to a long-form dataset
q_out_all_t <- melt(q_out_all%>% select(time,S,I,R,N,q), id.vars=c("time","q","N"))
# Plot S, I, R
ggplot(q_out_all_t) +
geom_line(aes(x=time,y=value/N*100,color=variable))+
ylab("Proportion of population")+
facet_wrap(.~q)+
theme_bw()
# Plot cumulative number of infections
ggplot(q_out_all) +
geom_point(aes(x=time,y=C))+
facet_wrap(.~q)+
ylab("Cumulative infections")+
theme_bw()
# 4. Quarantine rate
q_list <- c(0,0.05,0.1) # a vector of quarantine rate
q_out_all <- data.frame() # an empty dataset to save the outcome
for(this_q in q_list){
temp_param <- parameters #copy parameter
temp_param[['q']] <- this_q # replace q
# run ode solver
this_out <- data.frame(ode(y = state.q, times = times, func = OpenSIR_Qrtn, parms = temp_param))
# save q value in this cycle
this_out <- this_out %>%
mutate(N = S+I+R+Q,
q = this_q)
# stack the result
if(this_q == q_list[1]){
q_out_all <- this_out
}else{
q_out_all <- rbind(q_out_all, this_out)
}
}
# change the dataset to a long-form dataset
q_out_all_t <- melt(q_out_all%>% select(time,S,I,R,N,q), id.vars=c("time","q","N"))
# Plot S, I, R
ggplot(q_out_all_t) +
geom_line(aes(x=time,y=value/N*100,color=variable))+
ylab("Proportion of population")+
facet_wrap(.~q)+
theme_bw()
# Plot cumulative number of infections
ggplot(q_out_all) +
geom_point(aes(x=time,y=C))+
facet_wrap(.~q)+
ylab("Cumulative infections")+
theme_bw()
knitr::opts_chunk$set(echo = TRUE)
library(deSolve)
library(ggplot2)
library(reshape2)
library(dplyr)
# 1. Define model function
SI_CC<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
N = S + I + Tx
#SI w/o demography equations from lecture
dS <- -beta*S*I/N + rt*Tx
dI <- beta*S*I/N - si*I - c*b*Tx
dTx <- si*I + c*b*Tx - rt*Tx
# Cumulative incidence
dC <- beta*S*I/N
# return the rates of change as a list
list(c(dS, dI, dTx, dC))
})
}
#2. Define parameters and starting compartment sizes
parameters <- c(beta = 0.5, #effective contact rate (aka transmission rate)
rt = 0.1, # 1/duration of treatment and tracing
si = 0.1, # rate of seeking treatment
c = 0.05, # rate of contact tracing
b = 0.05# probability that a traced individual is infected
)
# Initial state
state <- c(S = 99999, #population of 100,000, 1 person starts of infected
I = 1,
Tx = 0,
C = 0)
T_end <- 500 #run model for 500 time steps (e.g. months)
times <- seq(0, T_end, by = 1) #runs the model for 500 time steps (e.g. months), and computes output at each time step
#Run the base-case
output.ct <- as.data.frame(ode(y = state, times = times, func = SI_CC, parms = parameters))
output.ct.t <- melt(output.ct %>% select(-C), id.vars="time")
ggplot(output.ct.t) +
geom_line(aes(time,value,color=variable))+
theme_bw()
# Sensitivity analysis on contact tracing rate
c_list <- c(0,0.05,0.1) # a vector of contact tracing rate
output_dt <- data.frame() # empty data to save outcomes
for (this_c in c_list){
temp <- parameters
# Replace latent period with the next value in the last
temp['c'] <- this_c
# Run ode solver
this_output <- data.frame(ode(y = state, times = times, func = SI_CC, parms = temp))
# Record current value of t_lat
this_output$c = as.character(this_c)
# Stack the result
output_dt <- rbind(output_dt, this_output)
}
# Plot the results with varying latent period
ggplot(output_dt)+
geom_line(aes(x=time, y=I, color=c, group=c))+
ylab("Infected")+
xlab("Time")+
theme_bw()
# Sensitivity analysis on contact tracing rate
c_list <- c(0,0.05,0.5) # a vector of contact tracing rate
output_dt <- data.frame() # empty data to save outcomes
for (this_c in c_list){
temp <- parameters
# Replace latent period with the next value in the last
temp['c'] <- this_c
# Run ode solver
this_output <- data.frame(ode(y = state, times = times, func = SI_CC, parms = temp))
# Record current value of t_lat
this_output$c = as.character(this_c)
# Stack the result
output_dt <- rbind(output_dt, this_output)
}
# Plot the results with varying latent period
ggplot(output_dt)+
geom_line(aes(x=time, y=I, color=c, group=c))+
ylab("Infected")+
xlab("Time")+
theme_bw()
# Sensitivity analysis on contact tracing rate
c_list <- c(0,0.3,0.5) # a vector of contact tracing rate
output_dt <- data.frame() # empty data to save outcomes
for (this_c in c_list){
temp <- parameters
# Replace latent period with the next value in the last
temp['c'] <- this_c
# Run ode solver
this_output <- data.frame(ode(y = state, times = times, func = SI_CC, parms = temp))
# Record current value of t_lat
this_output$c = as.character(this_c)
# Stack the result
output_dt <- rbind(output_dt, this_output)
}
# Plot the results with varying latent period
ggplot(output_dt)+
geom_line(aes(x=time, y=I, color=c, group=c))+
ylab("Infected")+
xlab("Time")+
theme_bw()
library(deSolve)
library(ggplot2)
library(reshape2)
library(ggpubr)
library(dplyr)
## Answers to the question 1 and 2 ##
## SEIRS model (a model with latent state and waning immunity) ##
#1. Define model function
# SEIRS model with births and deaths
OpenSEIRS<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
N = S + E + I + R
sigma = 1/t_lat # 1/latent period
#SIR w/ demography equations from lecture
dS <- -beta*S*I/N + birth*N - death*S + omega*R
dE <- beta*S*I/N - sigma*E - death*E
dI <- sigma*E - death*I - gamma*I
dR <- gamma*I - death*R - omega*R
dC <- beta*S*I/N
# return the rates of change as a list
list(c(dS, dE, dI, dR, dC))
})
}
#2. Define parameters and starting compartment sizes
parameters <- c(beta = 0.2, # place holder for effective contact rate (aka transmission rate)
gamma = 1/14, #recovery rate (1/duration infection)
birth = 12/1000/365,#0.0000027, #birth rate (per capita)
death = 12/1000/365, #all-cause mortality rate
omega = 1/(30.5*3),#0.01, # waning immunity
t_lat = 5 # latent period from E
)
beta_low <- 3*(parameters[["death"]] + parameters[["gamma"]])*(parameters[["death"]] + 1/parameters[["t_lat"]])*parameters[["t_lat"]]
beta_high <- 10*(parameters[["death"]] + parameters[["gamma"]])*(parameters[["death"]] + 1/parameters[["t_lat"]])*parameters[["t_lat"]]
state <- c(S = 10000-1, #population of 10,000, 1 person starts of infected
E = 0,
I = 1,
R = 0,
C = 0 #track cumulative number of infections
)
T_end <- 300 #run model for 300 time steps (e.g. days)
times <- seq(0, T_end, by = 1) #runs the model for 300 time steps (e.g. days), and computes output at each time step
#Run the base-case with lower beta (R0=3)
parameters['beta'] <- beta_low
out_lowbeta <- data.frame(ode(y = state, times = times, func = OpenSEIRS, parms = parameters))
out_lowbeta$totI <- out_lowbeta$E + out_lowbeta$I
#Run the base-case with higher beta (R0=10)
parameters['beta'] <- beta_high
out_highbeta <- data.frame(ode(y = state, times = times, func = OpenSEIRS, parms = parameters))
out_highbeta$totI <- out_highbeta$E + out_highbeta$I
# Plot S,E,I,R over time
out_lowbeta_t <- melt(out_lowbeta, id.vars='time')
ggplot(out_lowbeta_t)+
geom_line(aes(time,value,color=variable))+
ggtitle("R0 = 3")+
theme_bw()
max(out_lowbeta$C) #cumulative infections
out_highbeta_t <- melt(out_highbeta, id.vars='time')
ggplot(out_highbeta_t)+
geom_line(aes(time,value,color=variable))+
ggtitle("R0 = 10")+
theme_bw()
max(out_highbeta$C) #cumulative infections
# Plot E + I over time & peak of epidemics
totI <- data.frame(time = out_lowbeta$time, lowbeta = out_lowbeta$totI, highbeta = out_highbeta$totI)
ggplot(totI)+
geom_line(aes(time,lowbeta, color='low beta'))+
geom_line(aes(time,highbeta, color='high beta'))+
ylab("E + I")+
geom_vline(xintercept = c(which.max(totI$lowbeta),which.max(totI$highbeta)),
linetype = c("dashed","dashed"),
color = c("#0072B2","#D55E00"))+
annotate(geom="text",
label = c(as.character(which.max(totI$lowbeta)),as.character(which.max(totI$highbeta))),
x = c(which.max(totI$lowbeta),which.max(totI$highbeta)),
y = c(max(totI$lowbeta), max(totI$highbeta)),
color = c("#0072B2","#D55E00"),
hjust = -0.5)+
ggtitle("Total number of infections (E+I)")+
theme_bw()+
scale_color_manual(values = c("#D55E00","#0072B2"))
# Plot only I
onlyI <- data.frame(time = out_lowbeta$time, lowbeta = out_lowbeta$I, highbeta = out_highbeta$I)
ggplot(onlyI)+
geom_line(aes(time,lowbeta, color='low beta'))+
geom_line(aes(time,highbeta, color='high beta'))+
ylab("Infectious population")+
geom_vline(xintercept = c(which.max(onlyI$lowbeta),which.max(onlyI$highbeta)),
linetype = c("dashed","dashed"),
color = c("#0072B2","#D55E00"))+
annotate(geom="text",
label = c(as.character(which.max(onlyI$lowbeta)),as.character(which.max(onlyI$highbeta))),
x = c(which.max(onlyI$lowbeta),which.max(onlyI$highbeta)),
y = c(max(onlyI$lowbeta), max(onlyI$highbeta)),
color = c("#0072B2","#D55E00"),
hjust = -0.5)+
ggtitle("Total number of infectious individuals (I)")+
theme_bw()+
scale_color_manual(values = c("#D55E00","#0072B2"))
knitr::opts_chunk$set(echo = TRUE)
library(deSolve) #differential equation solver
library(tidyverse) #for manipulating dataframes and graphing in R
library(cowplot) #for combining multiple graphs on the same plot
parameters <- list(beta = 0.5, #effective contact rate
gamma = 0.3 #recovery rate (1/duration of infection)
)
state <- c(S = 99999, #population of 100,000, 1 person starts of infected
I = 1,
R = 0
) #these could also be proportions (0.99 and 0.01, for instance)
T_end <- 500 #run model for 500 time steps (e.g. months)
times <- seq(0, T_end, by = 1) #runs the model for 500 timesteps (e.g. months), computes output at each timestep 0 through 500
print(parameters)
print(state)
BasicSIR <- function(t, state, parameters) {
with(as.list(c(state, parameters)),{
N = S + I + R #define N (total population size)
#SIR model equations from slides - rates of change in and out of each compartment
dS <- -beta*S*I/N
dI <- beta*S*I/N - gamma*I
dR <- gamma*I
#return the rates of change as a list - IMPORTANT: must be same order as "state"
list(c(dS, dI, dR))
})
}
output <- ode(y = state, times = times, func = BasicSIR, parms = parameters)
print(head(output, 10)) #view output at the start and end of the modeled period
print(tail(output, 10))
output <- as.data.frame(output) %>% mutate(N=S+I+R)
output_long <- pivot_longer(output, cols=c("S","I","R"), names_to="state", values_to="size")
head(output_long)
plot_trace <-function(out) {
fig <- ggplot(out, aes(x=time, y=size/N, color=state)) +
geom_line(linewidth=1.25) +
labs(x='Time', y='Compartment proportions', color='') +
theme_bw() + theme(panel.grid=element_blank())
return(fig)
}
plot_trace(output_long %>% filter(time <= 200))
#basic reproductive number doesn't vary over time
R0 <- parameters[["beta"]]/parameters[["gamma"]]
print(R0)
#effective reproductive number Rt declines over time as % population susceptible declines
output <- output %>% mutate(Rt=R0*S/N)
head(output$Rt, 5)
tail(output$Rt, 5)
fig1 <- ggplot(output %>% filter(time<=200)) +
geom_line(aes(x=time, y=I/N)) +
labs(x="Time", y="% infected") +
theme_bw() + theme(panel.grid=element_blank())
fig2 <- ggplot(output %>% filter(time<=200)) +
geom_line(aes(x=time, y=Rt)) +
geom_hline(yintercept=1, linetype="dashed", color="red") +
labs(x="Time", y="R(t)") +
theme_bw() + theme(panel.grid=element_blank())
fig <- plot_grid(fig1, fig2, nrow=2)
fig
output_all <- list()
for(betas in c(0.2, 0.5, 1)) {
for(gammas in c(0.1, 0.3, 0.5)) {
parameters <- c("beta"=betas,
"gamma"=gammas)
output <- ode(y = state, times = times, func = BasicSIR, parms = parameters)
output_long <- pivot_longer(as.data.frame(output) %>% mutate(N=S+I+R),
cols=c("S","I","R"), names_to="state", values_to="size")
output_all <- c(output_all, list(output_long %>% mutate(beta=paste0("Beta: ", betas),
gamma=paste0("Gamma: ", gammas),
R0=paste0("R0: ", round(betas/gammas, 2)))))
}
}
output_all <- bind_rows(output_all)
output_all <- output_all %>% mutate(label=paste(beta, gamma, R0, sep="; "))
plot_trace(output_all) + facet_wrap(~label)
knitr::opts_chunk$set(echo = TRUE)
library(deSolve)
library(tidyverse)
plot_trace <-function(out) {
fig <- ggplot(out, aes(x=time, y=size/N, color=state)) +
geom_line(linewidth=1.25) +
labs(x='Time', y='Compartment proportions', color='') +
theme_bw() + theme(panel.grid=element_blank())
return(fig)
}
OpenSIR<-function(t, state, parameters) {
with(as.list(c(state, parameters)),{
N = S + I + R
#SIR w/ demography equations from the slides
dS <- -beta*S*I/N + birth*N - death*S
dI <- beta*S*I/N - death*I - gamma*I
dR <- gamma*I - death*R
# return the rates of change as a list
list(c(dS, dI, dR))
})
}
parameters <- list(beta = 0.5, #effective contact rate
gamma = 0.3, #recovery rate (1/duration infection)
birth = 0.02, #birth rate (per capita)
death = 0.02 #all-cause mortality rate
)
state <- c(S = 99999, #population of 100,000, 1 person starts of infected
I = 1,
R = 0
)
T_end <- 500 #run model for 500 time steps (e.g. months)
times <- seq(0, T_end, by = 1) #runs the model for 500 time steps (e.g. months), and computes output at each time step
output <- ode(y = state, times = times, func = OpenSIR, parms = parameters)
output <- as.data.frame(output) %>% mutate(N=S+I+R)
output_long <- pivot_longer(output, cols=c("S","I","R"), names_to="state", values_to="size")
plot_trace(output_long)
output[501, c("S", "I", "R")]/100000
R0 <- parameters[["beta"]]/(parameters[["gamma"]] + parameters[["death"]])
print(paste0("R0: ", R0))
# if R0 <= 1, there is no endemic equilibrium
# if R0 > 1, this is the endemic equilibrium:
S_star <- 1/R0
I_star <- (parameters[["death"]]/parameters[["beta"]])*(R0-1)
R_star <- 1-(S_star + I_star)
#see how this matches the proportions in the graph/from the model
print(paste0("Estimated prevalence at equilibrium: ", round(100*output$I[[T_end+1]]/output$N[[T_end+1]], 2), "%"))
print("Simulated prevalences at equilibrium:")
print(c("S_star"=S_star*100, "I_star"=I_star*100, "R_star"=R_star*100)) #prevalences at equilibrium
output <- output %>% mutate(Rt=R0*S/N)
#changes in Rt correlate w/ the oscillatory pattern in the trace graph
#changes in Rt are fueled by rises and falls in the susceptible population (from births and new infections, respectively)
plot_trace(output_long) +
geom_line(data=output, aes(x=time, y=Rt), color="black") +
geom_hline(yintercept=1, linetype="dashed", color="red")
output_all <- list()
for(rates in c(0, 0.01, 0.03, 0.1)) {
parameters[["birth"]] <- parameters[["death"]] <- rates
output <- ode(y = state, times = times, func = OpenSIR, parms = parameters)
output <- as.data.frame(output) %>%
mutate(N=S+I+R,
demo_rate=rates,
R0=parameters[["beta"]]/(parameters[["gamma"]] + rates),
Rt=R0*S/N,
demo_lab=paste0("Birth/death rate: ", demo_rate),
R0_lab=paste0("R0: ", round(R0, 2)),
I_star_lab=paste0("Prevalence at t=500: ", round(100*I[time==500]/N[time==500], 1)))
output_long <- pivot_longer(output, cols=c("S","I","R"), names_to="state", values_to="size")
output_all <- c(output_all, list(output_long))
}
output_all <- bind_rows(output_all)
plot_trace(output_all) + facet_wrap(~demo_lab+R0_lab+I_star_lab)
